#version 460

#extension GL_EXT_buffer_reference : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require

layout (local_size_x = 16, local_size_y = 16) in;


layout(buffer_reference, std430, buffer_reference_align = 1) buffer inputImageData
{
    uint8_t data[];
};


layout (set = 0, binding = 0, rgba8) uniform writeonly image2DArray imageListArray[64];


layout (std140, set = 1, binding = 0) uniform imageTransformInfo
{
	uint64_t srcData;
	uint srcImageWidth;
	uint srcImageHeight;
	uint16_t imageListIndex;
	uint16_t imageListLayerIndex;
} transformCommand;


void main()
{
	inputImageData inputData = inputImageData(transformCommand.srcData);
	
	uint indexX = gl_GlobalInvocationID.x;
	uint indexY = gl_GlobalInvocationID.y;

	if (indexX >= transformCommand.srcImageWidth || indexY >= transformCommand.srcImageHeight)
	{
        return; 
    }

    uint row = indexY;
	uint col = indexX;

	ivec3 coords = ivec3(col, row, transformCommand.imageListLayerIndex);
	
	float r = float(inputData.data[(indexX + indexY * transformCommand.srcImageWidth) * 3 + 0]) / 255.0;
	float g = float(inputData.data[(indexX + indexY * transformCommand.srcImageWidth) * 3 + 1]) / 255.0;
	float b = float(inputData.data[(indexX + indexY * transformCommand.srcImageWidth) * 3 + 2]) / 255.0;
	imageStore(imageListArray[transformCommand.imageListIndex], coords, vec4(r, g, b, 1.0));
}