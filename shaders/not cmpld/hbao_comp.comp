#version 460

#extension GL_GOOGLE_include_directive						: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8     : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16    : enable
#extension GL_KHR_shader_subgroup_ballot					: enable
#extension GL_KHR_shader_subgroup_arithmetic				: enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#define PI 3.141592653589

#define RAND_TEXTURE_SIZE 4

#define NUM_DIRECTIONS 6
#define NUM_STEPS 5

layout(push_constant) uniform PushConstants
{
	vec4 uvTransformData;
	
	vec2 invResolution;
	uvec2 resolution;
	
	float radius;
	float aoExponent;
	float angleBias;
	float negInvR2;
	
	float farPlane;
	float nearPlane;
} pushConstants;

layout(set = 0, binding = 0) uniform sampler2D depthTexture;
layout(set = 0, binding = 1) uniform sampler2D randTexture;
layout(set = 0, binding = 2, r16) uniform writeonly image2D resAO;


float getLinearDepth(float depth)
{  
	float far = pushConstants.farPlane; 
	float near = pushConstants.nearPlane;
	return (far * near) / (depth * (far - near) + near);
}
vec3 getPos(vec2 uv)
{
	float linDepth = getLinearDepth(texture(depthTexture, uv).x);
	vec4 transformData = pushConstants.uvTransformData;
	return vec3((uv * transformData.xy + transformData.zw) * linDepth, linDepth);
}
vec3 getPos(vec2 uv, float linDepth)
{
	vec4 transformData = pushConstants.uvTransformData;
	return vec3((uv * transformData.xy + transformData.zw) * linDepth, linDepth);
}
vec3 getNorm(vec2 uv, vec3 viewPos)
{
	float linDepth = viewPos.z;
	
	float resX = pushConstants.resolution.x; 
    vec4 H;
	H.x = getLinearDepth(texture(depthTexture, uv - vec2(1.0 / resX, 0.0)).x);
    H.y = getLinearDepth(texture(depthTexture, uv + vec2(1.0 / resX, 0.0)).x);
    H.z = getLinearDepth(texture(depthTexture, uv - vec2(2.0 / resX, 0.0)).x);
    H.w = getLinearDepth(texture(depthTexture, uv + vec2(2.0 / resX, 0.0)).x);
	
	vec2 he = abs(2.0 * H.xy - H.zw - linDepth);
    vec3 hDeriv;
    if (he.x < he.y)
        hDeriv = getPos(uv + vec2(1.0 / resX, 0.0), H.y) - viewPos;
    else
        hDeriv = -getPos(uv - vec2(1.0 / resX, 0.0), H.x) + viewPos;

	float resY = pushConstants.resolution.y; 
    vec4 V;
	V.x = getLinearDepth(texture(depthTexture, uv - vec2(0.0, 1.0 / resY)).x);
    V.y = getLinearDepth(texture(depthTexture, uv + vec2(0.0, 1.0 / resY)).x);
    V.z = getLinearDepth(texture(depthTexture, uv - vec2(0.0, 2.0 / resY)).x);
    V.w = getLinearDepth(texture(depthTexture, uv + vec2(0.0, 2.0 / resY)).x);
	
	vec2 ve = abs(2.0 * V.xy - V.zw - linDepth);
    vec3 vDeriv;
    if (ve.x < ve.y)
        vDeriv = getPos(uv + vec2(0.0, 1.0 / resY), V.y) - viewPos;
    else
        vDeriv = -getPos(uv - vec2(0.0, 1.0 / resY), V.x) + viewPos;

    return normalize(cross(hDeriv, vDeriv));
}
vec2 rotateDirection(vec2 dir, vec2 cosSin)
{
	return vec2(dir.x * cosSin.x - dir.y * cosSin.y, dir.x * cosSin.y + dir.y * cosSin.x);
}


float computeAO(vec3 P, vec3 N, vec3 S)
{
  vec3 V = S - P;
  float VdotV = dot(V, V);
  float NdotV = dot(N, V) * 1.0 / sqrt(VdotV);

  return clamp(NdotV - pushConstants.angleBias, 0.0, 1.0) * clamp(VdotV * pushConstants.negInvR2 + 1.0, 0.0, 1.0);
}
float computeAmbientOcclusion(vec2 uv, float pixelRad, vec4 randInp, vec3 viewPos, vec3 viewNorm)
{
	float stepSizePixels = pixelRad / (NUM_STEPS + 1);

	const float alpha = 2.0 * PI / NUM_DIRECTIONS;
	float occlusion = 0.0;
	
	for (float directionIndex = 0; directionIndex < NUM_DIRECTIONS; ++directionIndex)
    {
		float angle = alpha * directionIndex;
	
		vec2 direction = rotateDirection(vec2(cos(angle), sin(angle)), randInp.xy);
		float rayPixels = (randInp.z * stepSizePixels + 1.0);
	
		for (float stepIndex = 0; stepIndex < NUM_STEPS; ++stepIndex)
		{
			vec2 snappedUV = round(rayPixels * direction) * pushConstants.invResolution + uv;
			vec3 s = getPos(snappedUV);
		
			rayPixels += stepSizePixels;
			
			if (viewPos.z - s.z < 0.5)
				occlusion += computeAO(viewPos, viewNorm, s);
		}
    }

	occlusion *= pushConstants.aoExponent / (NUM_DIRECTIONS * NUM_STEPS);
	
	return 1.0 - occlusion * 2.0;
}
void main()
{
	ivec2 screenCoord = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
	if (screenCoord.x >= pushConstants.resolution.x || screenCoord.y >= pushConstants.resolution.y)
		return;
		
	vec2 UV = screenCoord * pushConstants.invResolution;
	vec3 viewPos = getPos(UV);
	vec3 viewNorm = getNorm(UV, viewPos);
	
	float pixelRad = min(pushConstants.radius / viewPos.z, 75.0);

	float AO = 1.0;
	
	if (subgroupMax(pixelRad) < 1.0)
	{
		imageStore(resAO, screenCoord, vec4(AO));
		return;
	}
		
	vec4 randInp = texture(randTexture, screenCoord / RAND_TEXTURE_SIZE);
	
	float result = computeAmbientOcclusion(UV, pixelRad, randInp, viewPos, viewNorm);
	
	AO = clamp(pow(result, pushConstants.aoExponent), 0.0, 1.0);

	imageStore(resAO, screenCoord, vec4(AO));
}