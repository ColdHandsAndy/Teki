#version 460

#extension GL_GOOGLE_include_directive						: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8     : enable

#include "misc.h"
#include "gi_data.h"

//Math
#define PI 3.141592653589
#define TWO_PI (2.0 * PI)
#define ONE_OVER_PI (1.0 / PI)
#define ONE_OVER_TWO_PI (1.0 / TWO_PI)
#define SQRT_2 1.41421356237309
#define ONE_OVER_SQRT_2 0.7071067811865475244

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(push_constant) uniform PushConsts 
{
	mat4 worldFromNDC;
	vec3 giSceneCenter;
	float pad;
	vec3 campos;
	uint skyboxEnabled;
} pushConstants;

layout(set = 0, binding = 0, r11f_g11f_b10f) uniform writeonly image2D SpecularImage;
layout(set = 0, binding = 1, r16f) uniform writeonly image2D DistanceImage;
layout(set = 0, binding = 2, r32f) uniform readonly image2D Depth;
layout(set = 0, binding = 3, rg8) uniform readonly image2D Refdir;
layout(set = 1, binding = 0) uniform MD
{
	GIMetaData data;
} giMetaData;

layout(set = 2, binding = 0, r32ui) uniform readonly uimage3D StableROMA[8];
layout(set = 2, binding = 1) uniform ViewMatricesStableROMA
{
	mat3x4 viewmats[8];
} viewmatsStableROMA;

layout(set = 3, binding = 0, rgba16ui) uniform readonly uimage3D EmissionMetRoughVoxelMap;
layout(set = 4, binding = 0, rgba8ui) uniform readonly uimage3D AlbedoNormalVoxelMap;

layout(set = 5, binding = 0) uniform sampler2D IrradianceProbes;
layout(set = 5, binding = 1) uniform sampler2D VisibilityProbes;

layout(set = 6, binding = 0) uniform samplerCube SamplerCubeMapRad;

layout(set = 7, binding = 0) uniform sampler2D BRDFLUT;


vec3 getProbeLighting(ProbeGridData gridData, vec3 relPos, vec3 N, vec3 V, float roughness, float alpha, vec3 F0, vec3 albedo, float diffAO)
{
	relPos += (N * 0.2 + V * 0.8) * gridData.shadowBias;

	vec3 gridPos = relPos - gridData.relOriginProbePos;
	vec3 gridCoord = gridPos * vec3(gridData.probeInvDistX, gridData.probeInvDistY, gridData.probeInvDistZ);
	vec3 baseProbeCoord = floor(gridCoord);
	vec3 trilValues = gridCoord - baseProbeCoord;
	
	bool outOfBounds = false;
	vec3 gridCenter = (gridData.relOriginProbePos + gridData.relEndProbePos) * 0.5;
	vec3 gridExtents = (gridData.relEndProbePos - gridData.relOriginProbePos) * 0.5;
	for (int axis = 0; axis < 3; ++axis)
	{
		outOfBounds = abs(relPos[axis] - gridCenter[axis]) > gridExtents[axis];
	}

	vec3 diffLD = vec3(0.0);
	if (!outOfBounds)
		diffLD = sampleProbeVolume(gridData, N, gridPos, gridCoord, baseProbeCoord, trilValues, IrradianceProbes, VisibilityProbes);

	float NdotV = max(dot(N, V), 0.0);
	vec2 DFG = texture(BRDFLUT, vec2(NdotV, roughness)).xy;
	vec3 Fr = max(vec3(1.0 - alpha), F0) - F0;
    vec3 kS = F0 + Fr * pow(1.0 - NdotV, 5.0);
    vec3 FssEss = kS * DFG.x + DFG.y;
    float Ems = (1.0 - (DFG.x + DFG.y));
    vec3 Favg = F0 + (1.0 - F0) / 21.0;
    vec3 FmsEms = Ems * FssEss * Favg / (1.0 - Favg * Ems);
    vec3 kD = albedo * (1.0 - FssEss - FmsEms) * diffAO;

    return (FmsEms + kD) * diffLD;
}

void traceFreeROMA(out vec3 radiance, out float hitDist, ProbeGridData gridData, VoxelizationData voxelData, vec3 rayOriginOccupationLocal, vec3 traceDir, int indexROMA)
{
	mat3 viewmat = 
		mat3(vec3(viewmatsStableROMA.viewmats[indexROMA][0].x, viewmatsStableROMA.viewmats[indexROMA][1].x, viewmatsStableROMA.viewmats[indexROMA][2].x), 
			 vec3(viewmatsStableROMA.viewmats[indexROMA][0].y, viewmatsStableROMA.viewmats[indexROMA][1].y, viewmatsStableROMA.viewmats[indexROMA][2].y), 
			 vec3(viewmatsStableROMA.viewmats[indexROMA][0].z, viewmatsStableROMA.viewmats[indexROMA][1].z, viewmatsStableROMA.viewmats[indexROMA][2].z));
	vec3 rayOriginROM = vec3((viewmat * rayOriginOccupationLocal + vec3(1.0)) * 0.5 * voxelData.resolutionROM);
	vec3 traceStep = viewmat * traceDir;

	if (!(all(greaterThanEqual(ivec3(rayOriginROM), ivec3(0))) && all(lessThan(ivec3(rayOriginROM), ivec3(voxelData.resolutionROM)))))
	{
		radiance = bool(pushConstants.skyboxEnabled) ? textureLod(SamplerCubeMapRad, traceDir, 0.0).rgb : vec3(0.0);
		hitDist = FLT16_MAX;
		return;
	}

	bool rayNoCollision = false;
	ivec3 rayCoord = ivec3(rayOriginROM);
	for (int i = 0; i < voxelData.resolutionROM; ++i)
	{
		int stripIndex = int(rayCoord.z / 32.0);
		uint rayStrip = imageLoad(StableROMA[indexROMA], ivec3(rayCoord.xy, stripIndex)).x;
		if (bool(rayStrip & (1 << (rayCoord.z % 32))))
			break;
		rayOriginROM += traceStep;
		rayCoord = ivec3(rayOriginROM);
		if (!(all(greaterThanEqual(rayCoord, ivec3(0))) && all(lessThan(rayCoord, ivec3(voxelData.resolutionROM)))))
		{
			rayNoCollision = true;
			break;
		}
	}
	if (rayNoCollision)
	{
		radiance = bool(pushConstants.skyboxEnabled) ? textureLod(SamplerCubeMapRad, traceDir, 0.0).rgb : vec3(0.0);
		hitDist = FLT16_MAX;
		return;
	}

	ivec3 rayIntersecROM = rayCoord;

	vec3 rayHitOccupationLocal = transpose(viewmat) * ((vec3(rayIntersecROM) + vec3(0.5)) / voxelData.resolutionROM * 2.0 - 1.0);

	ivec3 rayIntersecVM = ivec3(((rayHitOccupationLocal) * 0.5 + 0.5) * voxelData.resolutionVM);

	vec3 albedo;
	vec3 normal;
	unpackMaterialVM(albedo, normal, imageLoad(AlbedoNormalVoxelMap, rayIntersecVM));
	vec3 emission;
	float metalness;
	float roughness;
	unpackEmissionVM(emission, metalness, roughness, imageLoad(EmissionMetRoughVoxelMap, rayIntersecVM));

	vec3 F0 = mix(vec3(0.04), albedo, metalness);

	radiance = vec3(0.0);

	vec3 hitRelPos = rayHitOccupationLocal * voxelData.occupationHalfMeterSize;
	vec3 origRelPos = rayOriginOccupationLocal * voxelData.occupationHalfMeterSize;
	
	vec3 hoVec = origRelPos - hitRelPos;
	hitDist = length(hoVec);
	radiance += getProbeLighting(gridData, hitRelPos, normal, hoVec / hitDist, roughness, roughness * roughness, F0, albedo, 1.0);
	radiance += emission * (1.0 - metalness);
}

int getIndexROMA(int invocationIndex, bool positiveDirInvocation)
{
	const int[STABLE_ROM_NUMBER] indexLookUp
		= int[STABLE_ROM_NUMBER]
		//(
		//	7, 3, 0, 4,
		//	6, 2, 1, 5
		//);
		(
			3, 0,
			2, 1
		);
	return positiveDirInvocation ? invocationIndex : indexLookUp[invocationIndex - STABLE_ROM_NUMBER];
}

void main()
{
	ProbeGridData gridData = giMetaData.data.cascades[0].gridData;
	VoxelizationData voxelData = giMetaData.data.cascades[0].voxelData;

	ivec2 screenCoords = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);

	float depth = imageLoad(Depth, ivec2(screenCoords.x, screenCoords.y)).x;
	if (depth == 0.0)
		return;
	vec3 refdir = decodeOctohedralZeroToOne(imageLoad(Refdir, ivec2(screenCoords.x, screenCoords.y)).xy);

	vec2 screenUV = screenCoords * giMetaData.data.specData.invSpecImageRes;

	vec3 worldPos = getWorldPositionFromDepth(pushConstants.worldFromNDC, screenUV, depth);
	vec2 octohedral = clamp(encodeOctohedralZeroToOne(refdir), 0.0 + FLT32_EPSILON, 1.0 - FLT32_EPSILON);
	
	int indexROMA = int(int(octohedral.y * 2) * 4 + int(octohedral.x * 4));
	bool positiveDir = indexROMA < STABLE_ROM_NUMBER;
	indexROMA = getIndexROMA(indexROMA, positiveDir);
	
	vec3 normal = normalize((normalize(pushConstants.campos - worldPos) + refdir));
	worldPos += normal * voxelData.offsetNormalScaleROM;
	
	vec3 rayOriginOccupationLocal = (worldPos - pushConstants.giSceneCenter) * voxelData.invOccupationHalfMeterSize;
	
	vec3 specular;
	float hitDist;
	traceFreeROMA(specular, hitDist, gridData, voxelData, rayOriginOccupationLocal, refdir, indexROMA);

	imageStore(DistanceImage, screenCoords, vec4(hitDist, vec3(0.0)));
	imageStore(SpecularImage, screenCoords, vec4(vec3(specular), 0.0));
}