#version 460

#extension GL_GOOGLE_include_directive						: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8     : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16    : enable
#extension GL_KHR_shader_subgroup_ballot					: enable
#extension GL_KHR_shader_subgroup_arithmetic				: enable
#extension GL_EXT_samplerless_texture_functions				: enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "misc.h"
#include "tang_frame.h"
#include "lighting.h"
#include "pbr.h"
 
//Math
#define PI 3.141592653589
#define TWO_PI (2.0 * PI)
#define ONE_OVER_PI (1.0 / PI)
#define ONE_OVER_TWO_PI (1.0 / TWO_PI)
#define SQRT_2 1.41421356237309
#define ONE_OVER_SQRT_2 0.7071067811865475244

//PBR
#define RAD_MIP_COUNT 7

//Clustering
#define MAX_LIGHTS 1024
#define MAX_WORDS 32
#define Z_BIN_COUNT 8096
#define UINT16_MAX 65535
#define TILE_PIXEL_WIDTH 8
#define TILE_PIXEL_HEIGHT 8 

struct UVandGradients
{
	vec2 uv;
	vec2 uvDX;
	vec2 uvDY;
};

layout(push_constant) uniform PushConsts 
{
	vec3 camPos;
	float binWidth;
	vec2 invResolution;
	uint windowTileWidth;
	float nearPlane;
	float farPlane;
} pushConstants;

#define COORDINATE_TRANSFORMATION_SET_INDEX 0
#include "coordinate_transformation_set.h"

layout(set = 1, binding = 0, r32ui) uniform readonly uimage2D UV;
layout(set = 1, binding = 1, rgb10_a2) uniform readonly image2D TangentFramePacked;
layout(set = 1, binding = 2, r16ui) uniform readonly uimage2D DrawID;
layout(set = 1, binding = 3) uniform sampler2D Depth;
layout(set = 1, binding = 4, rgba16f) uniform writeonly image2D Framebuffer;

layout(set = 2, binding = 0) uniform sampler2DArray imageListArray[64];

layout(set = 3, binding = 0) uniform texture2DArray shadowMapArray[64];
layout(set = 3, binding = 1) uniform texture2DArray shadowCubeMapArray[64];
layout(set = 3, binding = 2) uniform sampler samplerS;
layout(set = 3, binding = 3) buffer ShadowViewMatrices
{
	mat4 matrices[];
} shadowViewMatrices;

layout(set = 4, binding = 0) uniform samplerCube samplerCubeMap;
layout(set = 4, binding = 1) uniform samplerCube samplerCubeMapRad;
layout(set = 4, binding = 2) uniform samplerCube samplerCubeMapIrrad;

layout(set = 5, binding = 0) buffer DrawDataBuffer 
{
    DrawData data[];
} drawData;

layout(set = 6, binding = 0) uniform sampler2D brdfLUT;
layout(set = 6, binding = 1) uniform sampler2D AO;

struct DirectionalLightLayout
{
    vec3 spectrum;
    vec3 direction;
};
layout(std140, set = 7, binding = 0) uniform DirectionalLight
{
    DirectionalLightLayout light;
} dirLight;
layout(set = 7, binding = 1) buffer LightsData
{
	UnifiedLightData lights[];
} lightsData;
const uint TYPE_POINT = 0;
const uint TYPE_SPOT = 1;
layout(std430, set = 7, binding = 2) buffer TypeData
{
	uint8_t types[];
} typeData;
layout(set = 7, binding = 3) buffer TilesData
{
	uint tilesWords[];
} tilesData;
struct ZBin
{
	uint16_t minI;
	uint16_t maxI;
};
layout(set = 7, binding = 4) buffer ZBinData
{
	ZBin data[];
} zBinData;



vec3 evaluateIBL(vec3 N, vec3 V, vec3 R, float NdotV, float alpha, float roughness, vec3 F0, vec3 DFG, vec3 albedo, float specAO, float diffAO)
{
    vec3 Fr = max(vec3(1.0 - alpha), F0) - F0;
    vec3 kS = F0 + Fr * pow(1.0 - NdotV, 5.0);

    vec3 FssEss = kS * DFG.x + DFG.y;

    float Ems = (1.0 - (DFG.x + DFG.y));
    vec3 Favg = F0 + (1.0 - F0) / 21.0;
    vec3 FmsEms = Ems * FssEss * Favg / (1.0 - Favg * Ems);
    vec3 kD = albedo * (1.0 - FssEss - FmsEms) * diffAO;
	float mipLevel = sqrt(roughness) * RAD_MIP_COUNT;
	vec3 specLD = textureLod(samplerCubeMapRad, R, mipLevel).rgb;
	vec3 diffLD = texture(samplerCubeMapIrrad, N).rgb;

    return FssEss * specLD * specAO + (FmsEms + kD) * diffLD;
}

float calcShadowingOnedir(int list, uint layer, vec3 shadingPointPos, uint viewmat, float angleCos, float lightSize, float NdotL)
{
	vec4 pos = vec4(shadingPointPos, 1.0);
	vec3 viewpos = vec3(shadowViewMatrices.matrices[viewmat] * pos);
	float projMod = angleCos / sqrt(1.0 - angleCos * angleCos);
	
	vec3 uv = vec3(vec2(((viewpos.x * projMod) / viewpos.z) * 0.5 + 0.5, ((viewpos.y * (-projMod)) / viewpos.z) * 0.5 + 0.5), float(layer) + 0.1);
	float depth = viewpos.z;
	
	float bias = max(0.2 * (1.0 - NdotL), 0.04);
	
	//return PCSS(depth, uv, lightSize, bias, pushConstants.nearPlane, samplerS, shadowMapArray[list]);
	return PCF(bias, depth, uv, samplerS, shadowMapArray[list]); 
}
float calcShadowingOmnidir(int list, vec3 shadingPointPos, uint viewmat, vec3 lightPos, float lightSize, float NdotL)
{
	vec3 dirvec = shadingPointPos - lightPos;
	float depth = max(max(abs(dirvec.x), abs(dirvec.y)), abs(dirvec.z));
	
	vec3 uv = getTexArrayCoordinateFromDirection(dirvec);
	
	float bias = max(0.2 * (1.0 - NdotL), 0.04);

	//return PCSS(depth, uv, lightSize, bias, pushConstants.nearPlane, samplerS, shadowCubeMapArray[list]);
	return PCF(bias, depth, uv, samplerS, shadowCubeMapArray[list]);
}
struct MaterialData
{
	vec3  F0;
	float roughness;
	vec3  albedo;
	float alpha;
	float alpha2;
	float diffAO;
	float specAO;
};
void evalLightTerms(out vec3 F, out vec3 Fr, out float Fd, float NdotV, float NdotL, float NdotH, float LdotH, MaterialData data)
{
	float D     = D_GGX(NdotH, data.alpha2);
	float Vis   = V_SmithGGXCorrelated(NdotV, NdotL, data.alpha2);
	F			= F_Schlick(data.F0, 1.0, LdotH);
	Fr			= D * F * Vis / PI;
	Fd			= Fr_DisneyDiffuse(NdotV, NdotL, LdotH, data.roughness) / PI;
}
vec3 directionalLightEval(vec3 V, vec3 N, float NdotV, MaterialData data)
{
	vec3 	L = -dirLight.light.direction;
	vec3 	H = normalize(L + V);
	float 	NdotL = clamp(dot(N, L), 0.0, 1.0);
	float 	NdotH = clamp(dot(N, H), 0.0, 1.0);
	float	LdotH = clamp(dot(L, H), 0.0, 1.0);
	
	vec3 	F;
	vec3 	Fr;
	float 	Fd;
	evalLightTerms(F, Fr, Fd, NdotV, NdotL, NdotH, LdotH, data);

	return (Fr * data.specAO + Fd * (vec3(1.0) - F) * data.albedo) * dirLight.light.spectrum * NdotL;
} 
vec3 pointLightEval(vec3 spectrum, vec3 unnormL, float radius, vec3 shadingPointPos, vec3 V, vec3 N, float NdotV, MaterialData data, int shadowList, uint viewmatIndex, vec3 lightPos, float lightSize)
{
	float	dist = length(unnormL);
	vec3 	L = normalize(unnormL);
	vec3 	H = normalize(L + V);
	float 	NdotL = clamp(dot(N, L), 0.0, 1.0);
	float 	NdotH = clamp(dot(N, H), 0.0, 1.0);
	float	LdotH = clamp(dot(L, H), 0.0, 1.0);
	
	vec3 	F;
	vec3 	Fr;
	float 	Fd;
	evalLightTerms(F, Fr, Fd, NdotV, NdotL, NdotH, LdotH, data);

	float sqrtNom = clamp(1 - pow(dist / radius, 4), 0.0, 1.0);
	float attenuationTerm = (sqrtNom * sqrtNom) / (dist * dist + 1.0);
	
	vec3 lighting = ((Fr * data.specAO + Fd * (vec3(1.0) - F)) * data.albedo) * spectrum * NdotL * attenuationTerm;
	float shadowing = 1.0;
	if (shadowList != -1)
		shadowing = calcShadowingOmnidir(shadowList, shadingPointPos, viewmatIndex, lightPos, lightSize, NdotL);

    return lighting * shadowing;   
}
vec3 spotLightEval(vec3 spectrum, vec3 direction, 
	vec3 unnormL, float lengthL, 
	float falloffCos, float cutoffCos, 
	vec3 shadingPointPos, vec3 V, vec3 N, float NdotV, 
	MaterialData data, int shadowList, uint shadowLayer, 
	uint viewmatIndex, float lightSize)
{
	float	dist = length(unnormL);
	vec3 	L = normalize(unnormL);
	vec3 	H = normalize(L + V);
	float 	NdotL = clamp(dot(N, L), 0.0, 1.0);
	float 	NdotH = clamp(dot(N, H), 0.0, 1.0);
	float	LdotH = clamp(dot(L, H), 0.0, 1.0);
	
	vec3 	F;
	vec3 	Fr;
	float 	Fd;
	evalLightTerms(F, Fr, Fd, NdotV, NdotL, NdotH, LdotH, data);
	
	float sqrtNom = clamp(1 - pow(dist / lengthL, 4), 0.0, 1.0);
	float attenuationTerm = (sqrtNom * sqrtNom) / (dist * dist + 1.0);
    float falloffIntensity = clamp((-dot(direction, L) - cutoffCos) / (falloffCos - cutoffCos), 0.0, 1.0);
	
	vec3 lighting = ((Fr * data.specAO + Fd * (vec3(1.0) - F)) * data.albedo) * spectrum * falloffIntensity * NdotL * attenuationTerm;
	float shadowing = 1.0;
	if (shadowList != -1)
		shadowing = calcShadowingOnedir(shadowList, shadowLayer, shadingPointPos, viewmatIndex, cutoffCos, lightSize, NdotL);

    return lighting * shadowing;
}

vec3 processLight(uint index, vec3 shadingPointPos, vec3 V, vec3 N, float NdotV, MaterialData data)
{
	UnifiedLightData light = lightsData.lights[index];
	uint type = typeData.types[index];
	
	vec3 result = vec3(0.0);
	switch (type)
	{
		case TYPE_POINT:
			result = pointLightEval(light.spectrum, light.position - shadingPointPos, light.lightLength, 
			shadingPointPos, V, N, NdotV, data, 
			light.shadowListIndex, light.shadowMatrixIndex, light.position, light.lightSize);
			break;
		case TYPE_SPOT:
			result = spotLightEval(light.spectrum, light.direction, light.position - shadingPointPos, light.lightLength, light.falloffCos, light.cutoffCos, 
			shadingPointPos, V, N, NdotV, data, 
			light.shadowListIndex, light.shadowLayerIndex, light.shadowMatrixIndex, light.lightSize);
			break;
		default:
			result = vec3(1.0, 0.0, 0.0);
			break;
	}
	return result;
}
uint getTileFirstWordFromScreenPosition(ivec2 screenCoord)
{
	uint xTile = uint(screenCoord.x / TILE_PIXEL_WIDTH);
	uint yTile = uint(screenCoord.y / TILE_PIXEL_HEIGHT);
	
	return (yTile * pushConstants.windowTileWidth + xTile) * MAX_WORDS;
}
void getZBinMinMaxData(float linearDepth, out uint minInd, out uint maxInd)
{
	uint zBinIndex = uint(linearDepth / pushConstants.binWidth);
	
	minInd = zBinIndex > Z_BIN_COUNT ? UINT16_MAX : zBinData.data[zBinIndex].minI;
	maxInd = zBinIndex > Z_BIN_COUNT ? 0 : zBinData.data[zBinIndex].maxI;
}

vec3 calculateLightContribution(ivec2 screenCoord, float linearDepth, vec3 shadingPointPos, vec3 V, vec3 N, float NdotV, MaterialData data)
{
	//Directional light contrib
	vec3 result = vec3(0.0);
    result += directionalLightEval(V, N, NdotV, data);
	
	
	//Lights and bins merged between workgroups to achieve uniformity
	uint wordMin = 0;
	uint wordMax = max(MAX_WORDS - 1, 0);
	
	uint tileWordsStart = getTileFirstWordFromScreenPosition(screenCoord);
	
	uint minIndexZ;
	uint maxIndexZ;
	getZBinMinMaxData(linearDepth, minIndexZ, maxIndexZ);
	
	uint mergedMin = subgroupMin(minIndexZ);
	uint mergedMax = subgroupMax(maxIndexZ);
	wordMin = max(mergedMin / 32, wordMin);
	wordMax = min(mergedMax / 32, wordMax);
	
	//
	//float modif = 1.0 / 2;
	//result = vec3(0.0, 1.0, 0.0);
	//
	for (uint wordIndex = wordMin; wordIndex <= wordMax; ++wordIndex)
	{
		uint mask = tilesData.tilesWords[tileWordsStart + wordIndex];
		
		//Try to get this out of the loop
		int localMin = clamp(int(minIndexZ) - int(wordIndex) * 32, 0, 31);
		int maskWidth = clamp(int(maxIndexZ) - int(minIndexZ) + 1, 0, 32);
		uint zBinMask = maskWidth == 32 ? uint(0xFFFFFFFF) : bitfieldInsert(0, uint(0xFFFFFFFF), localMin, maskWidth);
		mask &= zBinMask;

		uint mergedMask = subgroupOr(mask);
		while (mergedMask != 0)
		{
			uint bitIndex = findLSB(mergedMask);
			uint lightIndex = wordIndex * 32 + bitIndex;
			mergedMask ^= (1 << bitIndex);
			result += processLight(lightIndex, shadingPointPos, V, N, NdotV, data);
			//result += vec3(modif, -modif, 0.0);
		}
	}

    return result;
}

UVandGradients getUVData(ivec2 screenCoord, uint drawID)
{
	UVandGradients res;
	
	res.uv = unpackHalf2x16(imageLoad(UV, screenCoord).x);
	
	vec2 uvUp = unpackHalf2x16(imageLoad(UV, screenCoord + ivec2(0, 1)).x);
	vec2 uvDown = unpackHalf2x16(imageLoad(UV, screenCoord + ivec2(0, -1)).x);
	vec2 uvLeft = unpackHalf2x16(imageLoad(UV, screenCoord + ivec2(-1, 0)).x);
	vec2 uvRight = unpackHalf2x16(imageLoad(UV, screenCoord + ivec2(1, 0)).x);
	
	uint idUp = imageLoad(DrawID, screenCoord + ivec2(0, 1)).x;
	uint idDown = imageLoad(DrawID, screenCoord + ivec2(0, -1)).x;
	uint idLeft = imageLoad(DrawID, screenCoord + ivec2(-1, 0)).x;
	uint idRight = imageLoad(DrawID, screenCoord + ivec2(1, 0)).x;
	
	const float threshold = 0.05;
	
	vec2 dyUp = abs(uvUp - res.uv);
	vec2 dyDown = abs(uvDown - res.uv);
	vec2 dxLeft = abs(uvLeft - res.uv);
	vec2 dxRight = abs(uvRight - res.uv);
	bool up = all(lessThanEqual(dyUp, vec2(threshold))) && (drawID == idUp);
	bool down = all(lessThanEqual(dyDown, vec2(threshold))) && (drawID == idDown);
	bool left = all(lessThanEqual(dxLeft, vec2(threshold))) && (drawID == idLeft);
	bool right = all(lessThanEqual(dxRight, vec2(threshold))) && (drawID == idRight);
	
	res.uvDX = vec2(0.0);
	res.uvDY = vec2(0.0);
	
	if (up)
	{
		res.uvDY = dyUp;
	}
	else if (down)
	{
		res.uvDY = dyDown;
	}
	if (left)
	{
		res.uvDX = dxLeft;
	}
	else if (right)
	{
		res.uvDX = dxRight;
	}
	
	return res;
}
float getLinearDepth(float depth)
{  
	float far = pushConstants.farPlane; 
	float near = pushConstants.nearPlane;
	return (far * near) / (depth * (far - near) + near);
}
vec3 getWorldPositionFromDepth(vec2 uv, float depth)
{
	vec4 res = coordTransformData.worldFromNdc * vec4(uv * 2.0 - 1.0, depth, 1.0);
	return res.xyz / res.w;
}

void main()
{ 
	ivec2 screenCoord = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
	if (screenCoord.x >= int((1.0 / pushConstants.invResolution.x) + 0.1) || screenCoord.y >= int((1.0 / pushConstants.invResolution.y) + 0.1))
		return;

	float depth = texelFetch(Depth, screenCoord, 0).x;
	bool noWrite = (depth == 0.0);
	if (subgroupAnd(noWrite))
		return;

	vec2 screenUV = (vec2(screenCoord) + vec2(0.5)) * pushConstants.invResolution;

	uint drawID_frameHandednessBit = imageLoad(DrawID, screenCoord).x;
	bool bitIsOn = bool(drawID_frameHandednessBit & 0x8000);
	float handedness = bitIsOn ? 1.0 : -1.0;
	uint drawID = bitIsOn ? (drawID_frameHandednessBit ^ 0x8000) : drawID_frameHandednessBit;

	mat3 TNB = unpackTangentFrame(imageLoad(TangentFramePacked, screenCoord), handedness);
	UVandGradients uvAndGrads = getUVData(screenCoord, drawID_frameHandednessBit);
	float linearDepth = getLinearDepth(depth);
	vec3 worldPos = getWorldPositionFromDepth(screenUV, depth);
	
	DrawData drawData = drawData.data[drawID];
	
	vec3 N = TNB * normalize((textureGrad(imageListArray[drawData.nmIndexList], vec3(uvAndGrads.uv, drawData.nmIndexLayer + 0.1), uvAndGrads.uvDX, uvAndGrads.uvDY).xzy) * 2.0 - 1.0);
	vec3 V = normalize(pushConstants.camPos - worldPos);
	vec3 R = reflect(-V, N);
	
	float NdotV = abs(dot(N, V)) + 0.0001; 
	
	vec3 mrData = textureGrad(imageListArray[drawData.mrIndexList], vec3(uvAndGrads.uv, drawData.mrIndexLayer + 0.1), uvAndGrads.uvDX, uvAndGrads.uvDY).xyz;
	
	vec4 bcData = textureGrad(imageListArray[drawData.bcIndexList], vec3(uvAndGrads.uv, drawData.bcIndexLayer + 0.1), uvAndGrads.uvDX, uvAndGrads.uvDY);

	MaterialData data;
	data.albedo = bcData.xyz;
	data.F0 = mix(vec3(0.04), data.albedo, mrData.b);
	data.roughness = mrData.g;
	data.alpha = mrData.g * mrData.g + 0.001;
	data.alpha2 = data.alpha * data.alpha;
	data.diffAO = texture(AO, screenUV).x;
	data.specAO = computeSpecOcclusion(NdotV, data.diffAO, data.alpha);
	
	vec3 DFG = texture(brdfLUT, vec2(NdotV, data.roughness)).xyz;
	
	vec3 IBLcontrib = evaluateIBL(N, V, R, NdotV, data.alpha, data.roughness, data.F0, DFG, data.albedo, data.specAO, data.diffAO);
	vec3 lightsContrib = calculateLightContribution(screenCoord, linearDepth, worldPos, V, N, NdotV, data);

	vec3 emission = textureGrad(imageListArray[drawData.emIndexList], vec3(uvAndGrads.uv, drawData.emIndexLayer + 0.1), uvAndGrads.uvDX, uvAndGrads.uvDY).xyz;
	   
	vec3 result = lightsContrib + IBLcontrib + emission;

	imageStore(Framebuffer, screenCoord, vec4(result, 1.0));
}