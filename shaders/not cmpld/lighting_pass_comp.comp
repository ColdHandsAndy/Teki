#version 460

#extension GL_GOOGLE_include_directive						: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8     : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16    : enable
#extension GL_KHR_shader_subgroup_ballot					: enable
#extension GL_KHR_shader_subgroup_arithmetic				: enable
#extension GL_EXT_samplerless_texture_functions				: enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "misc.h"
#include "tang_frame.h"
#include "lighting.h"
#include "pbr.h"
#include "gi_data.h"
#include "bindless.h"
 
//Clustering
#define MAX_LIGHTS 1024
#define MAX_WORDS 32
#define Z_BIN_COUNT 8096
#define UINT16_MAX 65535
#define TILE_PIXEL_WIDTH 8
#define TILE_PIXEL_HEIGHT 8 

//Debug options
#define DISABLE_INDIRECT 0x00000001
#define DISPLAY_LIGHT_HEAT_MAP 0x00000002

struct UVandGradients
{
	vec2 uv;
	vec2 uvDX;
	vec2 uvDY;
};

layout(push_constant) uniform PushConsts 
{
	vec3 camPos;
	float binWidth;
	vec2 invResolution;
	uint windowTileWidth;
	float nearPlane;
	vec3 giSceneCenter;
	float farPlane;
	uint skyboxEnabled;
	uint debugOptionsBitfield;
} pushConstants;

#define COORDINATE_TRANSFORMATION_SET_INDEX 0
#include "coordinate_transformation_set.h"

layout(set = 1, binding = 0, r32ui) uniform readonly uimage2D UV;
layout(set = 1, binding = 1, rgb10_a2) uniform readonly image2D TangentFramePacked;
layout(set = 1, binding = 2, r16ui) uniform readonly uimage2D DrawID;
layout(set = 1, binding = 3) uniform sampler2D Depth;
layout(set = 1, binding = 4) uniform sampler2D AO;
layout(set = 1, binding = 5, rgba16f) uniform writeonly image2D Framebuffer;

layout(set = 2, binding = 0) uniform sampler2DArray imageListArray[64];

layout(set = 3, binding = 0) uniform texture2DArray shadowMapArray[64];
layout(set = 3, binding = 1) uniform texture2DArray shadowCubeMapArray[64];
layout(set = 3, binding = 2) uniform samplerShadow samplerS;
layout(set = 3, binding = 3) uniform sampler samplerNearest;
layout(set = 3, binding = 4) buffer ShadowViewMatrices
{
	mat4 matrices[];
} shadowViewMatrices;

layout(set = 4, binding = 0) uniform sampler2D IrradianceProbes;
layout(set = 4, binding = 1) uniform sampler2D VisibilityProbes;
layout(set = 5, binding = 0) uniform sampler2D SpecularImages[2];
layout(set = 6, binding = 0) uniform MD
{
	GIMetaData data;
} giMetaData;

layout(set = 7, binding = 0) uniform samplerCube SamplerCubeMapRad;

layout(set = 8, binding = 0) buffer DrawDataBuffer 
{
    DrawData data[];
} drawData;

layout(set = 9, binding = 0) uniform sampler2D brdfLUT;

struct DirectionalLightLayout
{
    vec3 spectrum;
    vec3 direction;
};
layout(std140, set = 10, binding = 0) uniform DirectionalLight
{
    DirectionalLightLayout light;
} dirLight;
layout(set = 10, binding = 1) buffer LightsData
{
	UnifiedLightData lights[];
} lightsData;
const uint TYPE_POINT = 0;
const uint TYPE_SPOT = 1;
layout(std430, set = 10, binding = 2) buffer TypeData
{
	uint8_t types[];
} typeData;
layout(set = 10, binding = 3) buffer TilesData
{
	uint tilesWords[];
} tilesData;
struct ZBin
{
	uint16_t minI;
	uint16_t maxI;
};
layout(set = 10, binding = 4) buffer ZBinData
{
	ZBin data[];
} zBinData;

vec3 calculateIndirectLighting(vec3 worldPos, vec3 N, vec3 V, vec3 R, float NdotV, float alpha, float roughness, vec3 F0, vec2 DFG, vec3 albedo, float specAO, float diffAO, vec2 screenUV)
{
	ProbeGridData gridData = giMetaData.data.cascades[0].gridData;

	vec3 originProbePos = pushConstants.giSceneCenter + gridData.relOriginProbePos;
	vec3 endProbePos = pushConstants.giSceneCenter + gridData.relEndProbePos;

	worldPos += (N * 0.2 + V * 0.8) * gridData.shadowBias;

	vec3 gridPos = worldPos - originProbePos;
	vec3 gridCoord = gridPos * vec3(gridData.probeInvDistX, gridData.probeInvDistY, gridData.probeInvDistZ);
	vec3 baseProbeCoord = floor(gridCoord);
	vec3 trilValues = gridCoord - baseProbeCoord;

	bool outOfBounds = false;
	vec3 gridCenter = (originProbePos + endProbePos) * 0.5;
	vec3 gridExtents = (endProbePos - originProbePos) * 0.5;
	for (int axis = 0; axis < 3; ++axis)
	{
		outOfBounds = abs(worldPos[axis] - gridCenter[axis]) > gridExtents[axis];
	}

	vec3 specLD = vec3(0.0);
	vec3 diffLD = vec3(0.0);
	if (true)
		diffLD = sampleProbeVolume(gridData, N, gridPos, gridCoord, baseProbeCoord, trilValues, IrradianceProbes, VisibilityProbes);

	//
	vec3 gl = texture(SpecularImages[0], screenUV).xyz;
	vec3 rg = texture(SpecularImages[1], screenUV).xyz;
	bool subgroupGlossy = subgroupMax(alpha) < 0.05;
	if (subgroupGlossy)
	{
		specLD = mix(gl, rg, alpha * 20.0);
		//specLD = textureLod(SamplerCubeMapRad, R, sqrt(roughness) * textureQueryLevels(SamplerCubeMapRad)).rgb;
	}
	else
	{
		if (alpha < 0.05)
			specLD = mix(gl, rg, alpha * 20.0);
		else
			specLD = sampleProbeVolume(gridData, R, gridPos, gridCoord, baseProbeCoord, trilValues, IrradianceProbes, VisibilityProbes);
	}
	//

	vec3 Fr = max(vec3(1.0 - alpha), F0) - F0;
    vec3 kS = F0 + Fr * pow(1.0 - NdotV, 5.0);

    vec3 FssEss = kS * DFG.x + DFG.y;

    float Ems = (1.0 - (DFG.x + DFG.y));
    vec3 Favg = F0 + (1.0 - F0) / 21.0;
    vec3 FmsEms = Ems * FssEss * Favg / (1.0 - Favg * Ems);
    vec3 kD = albedo * (1.0 - FssEss - FmsEms) * diffAO;

    return FssEss * specLD * specAO + (FmsEms + kD) * diffLD;
}

float calcShadowingOnedir(int list, uint layer, vec3 shadingPointPos, uint viewmat, float angleCos, float lightSize, vec3 N, float NdotL)
{
	vec4 pos = vec4(shadingPointPos + N * 0.15, 1.0);
	vec3 viewpos = vec3(shadowViewMatrices.matrices[viewmat] * pos);

	float projMod = angleCos / sqrt(1.0 - angleCos * angleCos);
	
	vec3 uv = vec3(vec2(((viewpos.x * projMod) / viewpos.z) * 0.5 + 0.5, ((viewpos.y * (-projMod)) / viewpos.z) * 0.5 + 0.5), float(layer) + 0.1);
	float depth = viewpos.z;
	
	float bias = max(0.15 * (1.0 - NdotL), 0.02);
	
	return PCF(bias, depth, uv, samplerS, shadowMapArray[list], ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y));
}
float calcShadowingOmnidir(int list, vec3 shadingPointPos, vec3 lightPos, float lightSize, vec3 N, float NdotL)
{
	vec3 dirvec = shadingPointPos + N * 0.15 - lightPos;
	float depth = max(max(abs(dirvec.x), abs(dirvec.y)), abs(dirvec.z));
	
	vec3 uv = getTexArrayCoordinateFromDirection(dirvec);
	
	float bias = max(0.15 * (1.0 - NdotL), 0.02);

	return PCF(bias, depth, uv, samplerS, shadowCubeMapArray[list], ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y));
}
struct MaterialData
{
	vec3  F0;
	float roughness;
	vec3  albedo;
	float alpha;
	float alpha2;
	float diffAO;
	float specAO;
};
void evalLightTerms(out vec3 F, out vec3 Fr, out float Fd, float NdotV, float NdotL, float NdotH, float LdotH, MaterialData data)
{
	float D     = D_GGX(NdotH, data.alpha2);
	float Vis   = V_SmithGGXCorrelated(NdotV, NdotL, data.alpha2);
	F			= F_Schlick(data.F0, 1.0, LdotH);
	Fr			= D * F * Vis / PI;
	Fd			= Fr_DisneyDiffuse(NdotV, NdotL, LdotH, data.roughness) / PI;
	//Fd			= Fr_LambertDiffuse();
}
vec3 directionalLightEval(vec3 V, vec3 N, float NdotV, MaterialData data)
{
	vec3 	L = -dirLight.light.direction;
	vec3 	H = normalize(L + V);
	float 	NdotL = clamp(dot(N, L), 0.0, 1.0);
	float 	NdotH = clamp(dot(N, H), 0.0, 1.0);
	float	LdotH = clamp(dot(L, H), 0.0, 1.0);
	
	vec3 	F;
	vec3 	Fr;
	float 	Fd;
	evalLightTerms(F, Fr, Fd, NdotV, NdotL, NdotH, LdotH, data);

	return (Fr * data.specAO + Fd * (vec3(1.0) - F) * data.albedo) * dirLight.light.spectrum * NdotL;
} 
vec3 pointLightEval(vec3 spectrum, vec3 unnormL, float radius, vec3 shadingPointPos, vec3 V, vec3 N, float NdotV, MaterialData data, int shadowList, vec3 lightPos, float lightSize)
{
	float	dist = length(unnormL);
	vec3 	L = normalize(unnormL);
	vec3 	H = normalize(L + V);
	float 	NdotL = clamp(dot(N, L), 0.0, 1.0);
	float 	NdotH = clamp(dot(N, H), 0.0, 1.0);
	float	LdotH = clamp(dot(L, H), 0.0, 1.0);
	
	vec3 	F;
	vec3 	Fr;
	float 	Fd;
	evalLightTerms(F, Fr, Fd, NdotV, NdotL, NdotH, LdotH, data);

	float sqrtNom = clamp(1 - pow(dist / radius, 4), 0.0, 1.0);
	float attenuationTerm = (sqrtNom * sqrtNom) / (dist * dist + 1.0);
	
	vec3 lighting = ((Fr * data.specAO + Fd * (vec3(1.0) - F)) * data.albedo) * spectrum * NdotL * attenuationTerm;
	float shadowing = 1.0;
	if (shadowList != -1)
		shadowing = calcShadowingOmnidir(shadowList, shadingPointPos, lightPos, lightSize, N, NdotL);

    return lighting * shadowing;   
}
vec3 spotLightEval(vec3 spectrum, vec3 direction, 
	vec3 unnormL, float lengthL, 
	float falloffCos, float cutoffCos, 
	vec3 shadingPointPos, vec3 V, vec3 N, float NdotV, 
	MaterialData data, int shadowList, uint shadowLayer, 
	uint viewmatIndex, float lightSize)
{
	float	dist = length(unnormL);
	vec3 	L = normalize(unnormL);
	vec3 	H = normalize(L + V);
	float 	NdotL = clamp(dot(N, L), 0.0, 1.0);
	float 	NdotH = clamp(dot(N, H), 0.0, 1.0);
	float	LdotH = clamp(dot(L, H), 0.0, 1.0);
	
	vec3 	F;
	vec3 	Fr;
	float 	Fd;
	evalLightTerms(F, Fr, Fd, NdotV, NdotL, NdotH, LdotH, data);
	
	float sqrtNom = clamp(1 - pow(dist / lengthL, 4), 0.0, 1.0);
	float attenuationTerm = (sqrtNom * sqrtNom) / (dist * dist + 1.0);
    float falloffIntensity = clamp((-dot(direction, L) - cutoffCos) / (falloffCos - cutoffCos), 0.0, 1.0);
	
	vec3 lighting = ((Fr * data.specAO + Fd * (vec3(1.0) - F)) * data.albedo) * spectrum * falloffIntensity * NdotL * attenuationTerm;
	float shadowing = 1.0;
	if (shadowList != -1)
		shadowing = calcShadowingOnedir(shadowList, shadowLayer, shadingPointPos, viewmatIndex, cutoffCos, lightSize, N, NdotL);

    return lighting * shadowing;
}

vec3 processLight(uint index, vec3 shadingPointPos, vec3 V, vec3 N, float NdotV, MaterialData data)
{
	UnifiedLightData light = lightsData.lights[index];
	uint type = typeData.types[index];
	
	vec3 result = vec3(0.0);
	switch (type)
	{
		case TYPE_POINT:
			result = pointLightEval(light.spectrum, light.position - shadingPointPos, light.lightLength, 
			shadingPointPos, V, N, NdotV, data, 
			light.shadowListIndex, light.position, light.lightSize);
			break;
		case TYPE_SPOT:
			result = spotLightEval(light.spectrum, light.direction, light.position - shadingPointPos, light.lightLength, light.falloffCos, light.cutoffCos, 
			shadingPointPos, V, N, NdotV, data, 
			light.shadowListIndex, light.shadowLayerIndex, light.shadowMatrixIndex, light.lightSize);
			break;
		default:
			result = vec3(1.0, 0.0, 0.0);
			break;
	}
	return result;
}
uint getTileFirstWordFromScreenPosition(ivec2 screenCoord)
{
	uint xTile = uint(screenCoord.x / TILE_PIXEL_WIDTH);
	uint yTile = uint(screenCoord.y / TILE_PIXEL_HEIGHT);
	
	return (yTile * pushConstants.windowTileWidth + xTile) * MAX_WORDS;
}
void getZBinMinMaxData(float linearDepth, out uint minInd, out uint maxInd)
{
	uint zBinIndex = uint(linearDepth / pushConstants.binWidth);
	
	minInd = zBinIndex > Z_BIN_COUNT ? UINT16_MAX : zBinData.data[zBinIndex].minI;
	maxInd = zBinIndex > Z_BIN_COUNT ? 0 : zBinData.data[zBinIndex].maxI;
}

vec3 calculateDirectLighting(ivec2 screenCoord, float linearDepth, vec3 shadingPointPos, vec3 V, vec3 N, float NdotV, MaterialData data)
{
	//Directional light contrib
	vec3 result = vec3(0.0);
    result += directionalLightEval(V, N, NdotV, data);
	
	
	//Lights and bins merged between workgroups to achieve uniformity
	uint wordMin = 0;
	uint wordMax = max(MAX_WORDS - 1, 0);
	
	uint tileWordsStart = getTileFirstWordFromScreenPosition(screenCoord);
	
	uint minIndexZ;
	uint maxIndexZ;
	getZBinMinMaxData(linearDepth, minIndexZ, maxIndexZ);
	
	uint mergedMin = subgroupMin(minIndexZ);
	uint mergedMax = subgroupMax(maxIndexZ);
	wordMin = max(mergedMin / 32, wordMin);
	wordMax = min(mergedMax / 32, wordMax);
	
	if (bool(pushConstants.debugOptionsBitfield & DISPLAY_LIGHT_HEAT_MAP))
	{
		const float manyLights = 10.0;
		const float modif = 1.0 / manyLights;
		result = vec3(0.0, 1.0, 0.0);
		
		for (uint wordIndex = wordMin; wordIndex <= wordMax; ++wordIndex)
		{
			uint mask = tilesData.tilesWords[tileWordsStart + wordIndex];
			
			//Try to get this out of the loop
			int localMin = clamp(int(minIndexZ) - int(wordIndex) * 32, 0, 31);
			int maskWidth = clamp(int(maxIndexZ) - int(minIndexZ) + 1, 0, 32);
			uint zBinMask = maskWidth == 32 ? uint(0xFFFFFFFF) : bitfieldInsert(0, uint(0xFFFFFFFF), localMin, maskWidth);
			mask &= zBinMask;

			uint mergedMask = subgroupOr(mask);
			while (mergedMask != 0)
			{
				uint bitIndex = findLSB(mergedMask);
				uint lightIndex = wordIndex * 32 + bitIndex;
				mergedMask ^= (1 << bitIndex);
				result += vec3(modif, -modif, 0.0);
			}
		}
	}
	else
	{
		for (uint wordIndex = wordMin; wordIndex <= wordMax; ++wordIndex)
		{
			uint mask = tilesData.tilesWords[tileWordsStart + wordIndex];
			
			//Try to get this out of the loop
			int localMin = clamp(int(minIndexZ) - int(wordIndex) * 32, 0, 31);
			int maskWidth = clamp(int(maxIndexZ) - int(minIndexZ) + 1, 0, 32);
			uint zBinMask = maskWidth == 32 ? uint(0xFFFFFFFF) : bitfieldInsert(0, uint(0xFFFFFFFF), localMin, maskWidth);
			mask &= zBinMask;

			uint mergedMask = subgroupOr(mask);
			while (mergedMask != 0)
			{
				uint bitIndex = findLSB(mergedMask);
				uint lightIndex = wordIndex * 32 + bitIndex;
				mergedMask ^= (1 << bitIndex);
				result += processLight(lightIndex, shadingPointPos, V, N, NdotV, data);
			}
		}
	}
    return result;
}

UVandGradients getUVData(ivec2 screenCoord, uint drawID)
{
	UVandGradients res;
	
	res.uv = unpackHalf2x16(imageLoad(UV, screenCoord).x);
	
	vec2 uvUp = unpackHalf2x16(imageLoad(UV, screenCoord + ivec2(0, 1)).x);
	vec2 uvDown = unpackHalf2x16(imageLoad(UV, screenCoord + ivec2(0, -1)).x);
	vec2 uvLeft = unpackHalf2x16(imageLoad(UV, screenCoord + ivec2(-1, 0)).x);
	vec2 uvRight = unpackHalf2x16(imageLoad(UV, screenCoord + ivec2(1, 0)).x);
	
	uint idUp = imageLoad(DrawID, screenCoord + ivec2(0, 1)).x;
	uint idDown = imageLoad(DrawID, screenCoord + ivec2(0, -1)).x;
	uint idLeft = imageLoad(DrawID, screenCoord + ivec2(-1, 0)).x;
	uint idRight = imageLoad(DrawID, screenCoord + ivec2(1, 0)).x;
	
	const float threshold = 0.05;
	
	vec2 dyUp = abs(uvUp - res.uv);
	vec2 dyDown = abs(uvDown - res.uv);
	vec2 dxLeft = abs(uvLeft - res.uv);
	vec2 dxRight = abs(uvRight - res.uv);
	bool up = all(lessThanEqual(dyUp, vec2(threshold))) && (drawID == idUp);
	bool down = all(lessThanEqual(dyDown, vec2(threshold))) && (drawID == idDown);
	bool left = all(lessThanEqual(dxLeft, vec2(threshold))) && (drawID == idLeft);
	bool right = all(lessThanEqual(dxRight, vec2(threshold))) && (drawID == idRight);
	
	res.uvDX = vec2(0.0);
	res.uvDY = vec2(0.0);
	
	if (up)
	{
		res.uvDY = dyUp;
	}
	else if (down)
	{
		res.uvDY = dyDown;
	}
	if (left)
	{
		res.uvDX = dxLeft;
	}
	else if (right)
	{
		res.uvDX = dxRight;
	}
	
	return res;
}
float getLinearDepth(float depth)
{  
	float far = pushConstants.farPlane; 
	float near = pushConstants.nearPlane;
	return (far * near) / (depth * (far - near) + near);
}
vec3 getWorldPositionFromDepth(vec2 uv, float depth)
{
	vec4 res = coordTransformData.worldFromNdc * vec4(uv * 2.0 - 1.0, depth, 1.0);
	return res.xyz / res.w;
}

void main()
{ 
	ivec2 screenCoord = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
	if (screenCoord.x >= int((1.0 / pushConstants.invResolution.x) + 0.1) || screenCoord.y >= int((1.0 / pushConstants.invResolution.y) + 0.1))
		return;

	float depth = texelFetch(Depth, screenCoord, 0).x;
	bool noWrite = (depth == 0.0);
	if (noWrite)
		return;

	vec2 screenUV = (vec2(screenCoord) + vec2(0.5)) * pushConstants.invResolution;

	uint drawID_frameHandednessBit = imageLoad(DrawID, screenCoord).x;
	bool bitIsOn = bool(drawID_frameHandednessBit & 0x8000);
	float handedness = bitIsOn ? 1.0 : -1.0;
	uint drawID = bitIsOn ? (drawID_frameHandednessBit ^ 0x8000) : drawID_frameHandednessBit;

	mat3 TNB = unpackTangentFrame(imageLoad(TangentFramePacked, screenCoord), handedness);
	UVandGradients uvAndGrads = getUVData(screenCoord, drawID_frameHandednessBit);
	float linearDepth = getLinearDepth(depth);
	vec3 worldPos = getWorldPositionFromDepth(screenUV, depth);
	
	DrawData drawData = drawData.data[drawID];
	
	vec3 N = TNB * normalize((textureGrad(imageListArray[drawData.nmIndexList], vec3(uvAndGrads.uv, drawData.nmIndexLayer + 0.1), uvAndGrads.uvDX, uvAndGrads.uvDY).xzy) * 2.0 - 1.0);
	vec3 V = normalize(pushConstants.camPos - worldPos);
	vec3 R = reflect(-V, N);
	
	float NdotV = abs(dot(N, V)) + 0.0001; 
	
	vec3 mrData = textureGrad(imageListArray[drawData.mrIndexList], vec3(uvAndGrads.uv, drawData.mrIndexLayer + 0.1), uvAndGrads.uvDX, uvAndGrads.uvDY).xyz;
	
	vec4 bcData = textureGrad(imageListArray[drawData.bcIndexList], vec3(uvAndGrads.uv, drawData.bcIndexLayer + 0.1), uvAndGrads.uvDX, uvAndGrads.uvDY);

	MaterialData data;
	data.albedo = bcData.xyz;
	data.F0 = mix(vec3(0.04), data.albedo, mrData.b);
	data.roughness = mrData.g;
	data.alpha = mrData.g * mrData.g + 0.001;
	data.alpha2 = data.alpha * data.alpha;
	data.diffAO = texture(AO, screenUV).x;
	data.specAO = computeSpecOcclusion(NdotV, data.diffAO, data.alpha);
	
	vec2 DFG = texture(brdfLUT, vec2(NdotV, data.roughness)).xy;
	
	vec3 directContrib = calculateDirectLighting(screenCoord, linearDepth, worldPos, V, N, NdotV, data);
	vec3 indirectContrib = calculateIndirectLighting(worldPos, N, V, R, NdotV, data.alpha, data.roughness, data.F0, DFG, data.albedo, data.specAO, data.diffAO, screenUV);

	vec3 emission = textureGrad(imageListArray[drawData.emIndexList], vec3(uvAndGrads.uv, drawData.emIndexLayer + 0.1), uvAndGrads.uvDX, uvAndGrads.uvDY).xyz;
	   
	vec3 result;
	if (bool(pushConstants.debugOptionsBitfield & DISABLE_INDIRECT))
		result = directContrib + emission;
	else
		result = directContrib + indirectContrib + emission;

	imageStore(Framebuffer, screenCoord, vec4(result, 1.0));
}